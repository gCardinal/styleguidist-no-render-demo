"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var path = require("path");
var ts = require("typescript");
var buildFilter_1 = require("./buildFilter");
exports.defaultParserOpts = {};
var defaultOptions = {
    jsx: ts.JsxEmit.React,
    module: ts.ModuleKind.CommonJS,
    target: ts.ScriptTarget.Latest
};
/**
 * Parses a file with default TS options
 * @param filePath component file that should be parsed
 */
function parse(filePath, parserOpts) {
    if (parserOpts === void 0) { parserOpts = exports.defaultParserOpts; }
    return withCompilerOptions(defaultOptions, parserOpts).parse(filePath);
}
exports.parse = parse;
/**
 * Constructs a parser for a default configuration.
 */
function withDefaultConfig(parserOpts) {
    if (parserOpts === void 0) { parserOpts = exports.defaultParserOpts; }
    return withCompilerOptions(defaultOptions, parserOpts);
}
exports.withDefaultConfig = withDefaultConfig;
/**
 * Constructs a parser for a specified tsconfig file.
 */
function withCustomConfig(tsconfigPath, parserOpts) {
    var basePath = path.dirname(tsconfigPath);
    var _a = ts.readConfigFile(tsconfigPath, function (filename) { return fs.readFileSync(filename, 'utf8'); }), configJson = _a.config, error = _a.error;
    if (error !== undefined) {
        throw error;
    }
    var _b = ts.convertCompilerOptionsFromJson(configJson.compilerOptions, basePath, tsconfigPath), options = _b.options, errors = _b.errors;
    if (errors && errors.length) {
        throw errors[0];
    }
    return withCompilerOptions(options, parserOpts);
}
exports.withCustomConfig = withCustomConfig;
/**
 * Constructs a parser for a specified set of TS compiler options.
 */
function withCompilerOptions(compilerOptions, parserOpts) {
    if (parserOpts === void 0) { parserOpts = exports.defaultParserOpts; }
    return {
        parse: function (filePath) {
            var program = ts.createProgram([filePath], compilerOptions);
            var parser = new Parser(program, parserOpts);
            var checker = program.getTypeChecker();
            var sourceFile = program.getSourceFile(filePath);
            var moduleSymbol = checker.getSymbolAtLocation(sourceFile);
            if (!moduleSymbol) {
                return [];
            }
            var exports = checker.getExportsOfModule(moduleSymbol);
            var components = exports
                .map(function (exp) { return parser.getComponentInfo(exp, sourceFile); })
                .filter(function (comp) { return comp; });
            // this should filter out components with the same name as default export
            var filteredComponents = components
                .filter(function (comp) { return !!comp; })
                .filter(function (comp, index) {
                var isUnique = components
                    .filter(function (cmp) { return !!cmp; })
                    .slice(index + 1)
                    .filter(function (innerComp) { return innerComp.displayName === comp.displayName; })
                    .length === 0;
                return isUnique;
            });
            return filteredComponents;
        }
    };
}
exports.withCompilerOptions = withCompilerOptions;
var defaultJSDoc = {
    description: '',
    fullComment: '',
    tags: {}
};
var Parser = /** @class */ (function () {
    function Parser(program, opts) {
        this.checker = program.getTypeChecker();
        this.propFilter = buildFilter_1.buildFilter(opts);
    }
    Parser.prototype.getComponentInfo = function (exp, source) {
        if (!!exp.declarations && exp.declarations.length === 0) {
            return null;
        }
        var type = this.checker.getTypeOfSymbolAtLocation(exp, exp.valueDeclaration || exp.declarations[0]);
        var commentSource = exp;
        if (!exp.valueDeclaration) {
            if (!type.symbol) {
                return null;
            }
            exp = type.symbol;
            if (type.symbol.getName() === 'StatelessComponent') {
                commentSource = this.checker.getAliasedSymbol(commentSource);
            }
            else {
                commentSource = exp;
            }
        }
        var propsType = this.extractPropsFromTypeIfStatelessComponent(type);
        if (!propsType) {
            propsType = this.extractPropsFromTypeIfStatefulComponent(type);
        }
        if (propsType) {
            var componentName = computeComponentName(exp, source);
            var defaultProps = this.extractDefaultPropsFromComponent(exp, source);
            var props = this.getPropsInfo(propsType, defaultProps);
            for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
                var propName = _a[_i];
                var prop = props[propName];
                var component = { name: componentName };
                if (!this.propFilter(prop, component)) {
                    delete props[propName];
                }
            }
            return {
                description: this.findDocComment(commentSource).fullComment,
                displayName: componentName,
                props: props
            };
        }
        return null;
    };
    Parser.prototype.extractPropsFromTypeIfStatelessComponent = function (type) {
        var callSignatures = type.getCallSignatures();
        if (callSignatures.length) {
            // Could be a stateless component.  Is a function, so the props object we're interested
            // in is the (only) parameter.
            for (var _i = 0, callSignatures_1 = callSignatures; _i < callSignatures_1.length; _i++) {
                var sig = callSignatures_1[_i];
                var params = sig.getParameters();
                if (params.length === 0) {
                    continue;
                }
                // Maybe we could check return type instead,
                // but not sure if Element, ReactElement<T> are all possible values
                var propsParam = params[0];
                if (propsParam.name === 'props' || params.length === 1) {
                    return propsParam;
                }
            }
        }
        return null;
    };
    Parser.prototype.extractPropsFromTypeIfStatefulComponent = function (type) {
        var constructSignatures = type.getConstructSignatures();
        if (constructSignatures.length) {
            // React.Component. Is a class, so the props object we're interested
            // in is the type of 'props' property of the object constructed by the class.
            for (var _i = 0, constructSignatures_1 = constructSignatures; _i < constructSignatures_1.length; _i++) {
                var sig = constructSignatures_1[_i];
                var instanceType = sig.getReturnType();
                var props = instanceType.getProperty('props');
                if (props) {
                    return props;
                }
            }
        }
        return null;
    };
    Parser.prototype.getPropsInfo = function (propsObj, defaultProps) {
        var _this = this;
        if (defaultProps === void 0) { defaultProps = {}; }
        if (!propsObj.valueDeclaration) {
            return {};
        }
        var propsType = this.checker.getTypeOfSymbolAtLocation(propsObj, propsObj.valueDeclaration);
        var propertiesOfProps = propsType.getProperties();
        var result = {};
        propertiesOfProps.forEach(function (prop) {
            var propName = prop.getName();
            // Find type of prop by looking in context of the props object itself.
            var propType = _this.checker.getTypeOfSymbolAtLocation(prop, propsObj.valueDeclaration);
            var propTypeString = _this.checker.typeToString(propType);
            // tslint:disable-next-line:no-bitwise
            var isOptional = (prop.getFlags() & ts.SymbolFlags.Optional) !== 0;
            var jsDocComment = _this.findDocComment(prop);
            var defaultValue = null;
            if (defaultProps[propName] !== undefined) {
                defaultValue = { value: defaultProps[propName] };
            }
            else if (jsDocComment.tags.default) {
                defaultValue = { value: jsDocComment.tags.default };
            }
            result[propName] = {
                defaultValue: defaultValue,
                description: jsDocComment.fullComment,
                name: propName,
                required: !isOptional,
                type: { name: propTypeString }
            };
        });
        return result;
    };
    Parser.prototype.findDocComment = function (symbol) {
        var _this = this;
        var comment = this.getFullJsDocComment(symbol);
        if (comment.fullComment) {
            return comment;
        }
        var rootSymbols = this.checker.getRootSymbols(symbol);
        var commentsOnRootSymbols = rootSymbols
            .filter(function (x) { return x !== symbol; })
            .map(function (x) { return _this.getFullJsDocComment(x); })
            .filter(function (x) { return !!x.fullComment; });
        if (commentsOnRootSymbols.length) {
            return commentsOnRootSymbols[0];
        }
        return defaultJSDoc;
    };
    /**
     * Extracts a full JsDoc comment from a symbol, even
     * though TypeScript has broken down the JsDoc comment into plain
     * text and JsDoc tags.
     */
    Parser.prototype.getFullJsDocComment = function (symbol) {
        // in some cases this can be undefined (Pick<Type, 'prop1'|'prop2'>)
        if (symbol.getDocumentationComment === undefined) {
            return defaultJSDoc;
        }
        var mainComment = ts.displayPartsToString(symbol.getDocumentationComment());
        var tags = symbol.getJsDocTags() || [];
        var tagComments = [];
        var tagMap = {};
        tags.forEach(function (tag) {
            var trimmedText = (tag.text || '').trim();
            var currentValue = tagMap[tag.name];
            tagMap[tag.name] = currentValue
                ? currentValue + '\n' + trimmedText
                : trimmedText;
            if (tag.name !== 'default') {
                tagComments.push(formatTag(tag));
            }
        });
        return {
            description: mainComment,
            fullComment: (mainComment + '\n' + tagComments.join('\n')).trim(),
            tags: tagMap
        };
    };
    Parser.prototype.extractDefaultPropsFromComponent = function (symbol, source) {
        var _this = this;
        var possibleStatements = source.statements
            .filter(function (stmt) { return !!stmt.name; })
            .filter(function (stmt) {
            return _this.checker.getSymbolAtLocation(stmt.name) === symbol;
        });
        if (!possibleStatements.length) {
            // if no class declaration is found, try to find a
            // expression statement used in a React.StatelessComponent
            possibleStatements = source.statements.filter(function (stmt) {
                return ts.isExpressionStatement(stmt);
            });
        }
        if (!possibleStatements.length) {
            return {};
        }
        var statement = possibleStatements[0];
        if (statementIsClassDeclaration(statement) && statement.members.length) {
            var possibleDefaultProps = statement.members.filter(function (member) { return member.name && getPropertyName(member.name) === 'defaultProps'; });
            if (!possibleDefaultProps.length) {
                return {};
            }
            var defaultProps = possibleDefaultProps[0];
            var initializer = defaultProps.initializer;
            var properties = initializer.properties;
            var propMap = getPropMap(properties);
            return propMap;
        }
        else if (statementIsStateless(statement)) {
            var propMap_1 = {};
            statement.getChildren().forEach(function (child) {
                var right = child.right;
                if (right) {
                    var properties = right.properties;
                    propMap_1 = getPropMap(properties);
                }
            });
            return propMap_1;
        }
        return {};
    };
    return Parser;
}());
function statementIsClassDeclaration(statement) {
    return !!statement.members;
}
function statementIsStateless(statement) {
    var children = statement.getChildren();
    for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
        var child = children_1[_i];
        var left = child.left;
        if (left) {
            var name_1 = left.name;
            if (name_1.escapedText === 'defaultProps') {
                return true;
            }
        }
    }
    return false;
}
function getPropMap(properties) {
    var propMap = properties.reduce(function (acc, property) {
        var literalValue = getLiteralValueFromPropertyAssignment(property);
        var propertyName = getPropertyName(property.name);
        if (typeof literalValue === 'string' && propertyName !== null) {
            var value = getLiteralValueFromPropertyAssignment(property);
            if (value !== null) {
                acc[propertyName] = value;
            }
        }
        return acc;
    }, {});
    return propMap;
}
function getPropertyName(name) {
    switch (name.kind) {
        case ts.SyntaxKind.NumericLiteral:
        case ts.SyntaxKind.StringLiteral:
        case ts.SyntaxKind.Identifier:
            return name.text;
        case ts.SyntaxKind.ComputedPropertyName:
            return name.getText();
        default:
            return null;
    }
}
function getLiteralValueFromPropertyAssignment(property) {
    var initializer = property.initializer;
    switch (initializer.kind) {
        case ts.SyntaxKind.FalseKeyword:
            return 'false';
        case ts.SyntaxKind.TrueKeyword:
            return 'true';
        case ts.SyntaxKind.StringLiteral:
            return initializer.text.trim();
        case ts.SyntaxKind.PrefixUnaryExpression:
            return initializer.getFullText().trim();
        case ts.SyntaxKind.NumericLiteral:
            return "" + initializer.text;
        case ts.SyntaxKind.NullKeyword:
            return 'null';
        case ts.SyntaxKind.Identifier:
            // can potentially find other identifiers in the source and map those in the future
            return initializer.text === 'undefined'
                ? 'undefined'
                : null;
        case ts.SyntaxKind.ObjectLiteralExpression:
            // return the source text for an object literal
            return initializer.getText();
        default:
            return null;
    }
}
function formatTag(tag) {
    var result = '@' + tag.name;
    if (tag.text) {
        result += ' ' + tag.text;
    }
    return result;
}
function computeComponentName(exp, source) {
    var exportName = exp.getName();
    if (exportName === 'default' ||
        exportName === '__function' ||
        exportName === 'StatelessComponent') {
        // Default export for a file: named after file
        return path.basename(source.fileName, path.extname(source.fileName));
    }
    else {
        return exportName;
    }
}
//# sourceMappingURL=parser.js.map