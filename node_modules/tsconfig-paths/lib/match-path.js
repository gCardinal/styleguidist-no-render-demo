"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var package_reader_1 = require("./package-reader");
var fs = require("fs");
var path = require("path");
var match_star_1 = require("./match-star");
/**
 * Creates a function that can resolve paths according to tsconfig paths property.
 * @param tsConfigPath The paths where tsconfig.json is located.
 * @param baseUrl The baseUrl specified in tsconfig.
 * @param paths The paths specified in tsconfig.
 */
function createMatchPath(absoluteBaseUrl, paths) {
    // Resolve all paths to absolute form once here, this saves time on each request later.
    // We also add the baseUrl as a base which will be replace if specified in paths. This is how typescript works
    var absolutePaths = Object.keys(paths)
        .reduce(function (soFar, key) {
        return (__assign({}, soFar, (_a = {}, _a[key] = paths[key]
            .map(function (pathToResolve) { return path.join(absoluteBaseUrl, pathToResolve); }), _a)));
        var _a;
    }, {
        "*": [absoluteBaseUrl.replace(/\/$/, "") + "/*"],
    });
    return function (sourceFileName, requestedModule, readPackageJson, fileExists, extensions) {
        return matchFromAbsolutePaths(absolutePaths, sourceFileName, requestedModule, readPackageJson, fileExists, extensions);
    };
}
exports.createMatchPath = createMatchPath;
/**
 * Finds a path from tsconfig that matches a module load request.
 * @param absolutePathMappings The paths to try as specified in tsconfig but resolved to absolute form.
 * @param absoluteSourceFileName Absolute path to the file that requested the module.
 * @param requestedModule The required module name.
 * @param readPackageJson Function that returns parsed package.json if exists or undefined(useful for testing).
 * @param fileExists Function that checks for existance of a file (useful for testing).
 * @param extensions File extensions to probe for (useful for testing).
 * @returns the found path, or undefined if no path was found.
 */
function matchFromAbsolutePaths(absolutePathMappings, absoluteSourceFileName, requestedModule, readPackageJson, fileExists, extensions) {
    if (readPackageJson === void 0) { readPackageJson = function (packageJsonPath) { return package_reader_1.readPackage(packageJsonPath); }; }
    if (fileExists === void 0) { fileExists = fs.existsSync; }
    if (extensions === void 0) { extensions = Object.keys(require.extensions); }
    if (requestedModule[0] !== '.'
        && requestedModule[0] !== path.sep
        && absolutePathMappings
        && absoluteSourceFileName
        && requestedModule
        && fileExists) {
        for (var _i = 0, _a = sortByLongestPrefix(Object.keys(absolutePathMappings)); _i < _a.length; _i++) {
            var virtualPathPattern = _a[_i];
            var starMatch = virtualPathPattern === requestedModule ? '' : match_star_1.matchStar(virtualPathPattern, requestedModule);
            if (starMatch !== undefined) {
                for (var _b = 0, _c = absolutePathMappings[virtualPathPattern]; _b < _c.length; _b++) {
                    var physicalPathPattern = _c[_b];
                    var physicalPath = physicalPathPattern.replace('*', starMatch);
                    var resolved = tryResolve(physicalPath, fileExists, readPackageJson, extensions);
                    if (resolved) {
                        return resolved;
                    }
                }
            }
        }
    }
    return undefined;
}
exports.matchFromAbsolutePaths = matchFromAbsolutePaths;
/**
 * Tries to resolve a physical path by:
 * 1. Check for files named as last part of request and ending in any of the extensions.
 * 2. Check for file specified in package.json's main property.
 * 3. Check for a file named index ending in any of the extensions.
 * @param physicalPath The path to check.
 * @param fileExists Function that checks for existance of a file (useful for testing).
 * @param readPackageJson Function that returns parsed package.json if exists or undefined(useful for testing).
 * @param extensions File extensions to probe for (useful for testing).
 * @returns {string}
 */
function tryResolve(physicalPath, fileExists, readPackageJson, extensions) {
    if (path.extname(path.basename(physicalPath)).length > 0 && fileExists(physicalPath)) {
        return physicalPath;
    }
    if (extensions.reduce(function (prev, curr) { return prev || fileExists(physicalPath + curr); }, false)) {
        return physicalPath;
    }
    var packageJson = readPackageJson(path.join(physicalPath, "/package.json"));
    if (packageJson && packageJson.main && fileExists(path.join(physicalPath, packageJson.main))) {
        var file = path.join(physicalPath, packageJson.main);
        var fileExtension = path.extname(file).replace(/^\./, "");
        var fileExtensionRegex = new RegExp("." + fileExtension + "$");
        return fileExtension ? file.replace(fileExtensionRegex, "") : file;
    }
    var indexPath = path.join(physicalPath, "/index");
    return extensions.reduce(function (prev, curr) { return prev || fileExists(indexPath + curr) && physicalPath; }, "");
}
/**
 * Sort path patterns.
 * If module name can be matches with multiple patterns then pattern with the longest prefix will be picked.
 */
function sortByLongestPrefix(arr) {
    return arr
        .concat()
        .sort(function (a, b) { return getPrefixLength(b) - getPrefixLength(a); });
}
function getPrefixLength(pattern) {
    var prefixLength = pattern.indexOf("*");
    return pattern.substr(0, prefixLength).length;
}
